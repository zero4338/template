{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"default": {
		"prefix": "default",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"int read()",
			"{",
			"\tint ret=0;bool f=0;char c=getchar();",
			"\twhile(c>'9'||c<'0')f|=(c=='-'),c=getchar();",
			"\twhile(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();",
			"\treturn f?-ret:ret;",
			"}",
			"int main()",
			"{",
			"\t$0",
			"}"
		]
	},
	"polynomial": {
		"prefix": "znomial",
		"body": [
			"class poly",
			"{",
			"\tstatic int R[1<<21];",
			"\tstatic mint W[1<<21];",
			"\tprivate:",
			"\tvector<mint>v;",
			"\tvoid ntt(int L,int typ)",
			"\t{",
			"\t\tint n=1<<L;",
			"\t\tfor(int i=0;i<n;i++)R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));",
			"\t\tW[0]=1;W[1]=qpow((mint)3,(mod-1)/n);if(typ==-1)W[1]=qpow(W[1],mod-2);",
			"\t\tfor(int i=2;i<n;i++)W[i]=W[i-1]*W[1];",
			"\t\tset(n);",
			"\t\tfor(int i=0;i<n;i++)if(R[i]>i)swap(v[R[i]],v[i]);",
			"\t\tfor(int t=n>>1,d=1;d<n;d<<=1,t>>=1)",
			"\t\t\tfor(int i=0;i<n;i+=(d<<1))",
			"\t\t\t\tfor(int j=0;j<d;j++)",
			"\t\t\t\t{",
			"\t\t\t\t\tmint tmp=W[t*j]*v[i+j+d];",
			"\t\t\t\t\tv[i+j+d]=v[i+j]-tmp;",
			"\t\t\t\t\tv[i+j]+=tmp;",
			"\t\t\t\t}",
			"\t\tif(typ==-1){mint inv=qpow((mint)n,mod-2);for(int i=0;i<n;i++)v[i]*=inv;}",
			"\t}",
			"\tvoid adjust(){while(len()>1&&v.back().v==0)v.pop_back();}",
			"\tpublic:",
			"\tpoly()=default;",
			"\tpoly(initializer_list<mint>_v):v(_v){}",
			"\tvoid init(int n){v.resize(n);generate(v.begin(),v.end(),read);}",
			"\tmint&operator[](const int &i){return v[i];}",
			"\tconst mint& operator[](const int &i)const{return v[i];}",
			"\tint len()const{return v.size();}",
			"\tvoid set(int l){v.resize(l);}",
			"\tpoly operator *(poly rhs)",
			"\t{",
			"\t\tpoly ret,tmp=*this;",
			"\t\tint L=ceil(log2(tmp.len()+rhs.len()-1)),n=1<<L;",
			"\t\ttmp.ntt(L,1);rhs.ntt(L,1);",
			"\t\tret.set(n);",
			"\t\tfor(int i=0;i<n;i++)ret[i]=tmp[i]*rhs[i];",
			"\t\tret.ntt(L,-1);ret.adjust();",
			"\t\treturn ret;",
			"\t}",
			"\tvoid operator *=(poly rhs)",
			"\t{",
			"\t\tint L=ceil(log2(len()+rhs.len()-1)),n=1<<L;",
			"\t\tntt(L,1);rhs.ntt(L,1);",
			"\t\tfor(int i=0;i<n;i++)v[i]*=rhs[i];",
			"\t\tntt(L,-1);adjust();",
			"\t}",
			"\tpoly operator +(const poly &rhs)",
			"\t{",
			"\t\tpoly ret;",
			"\t\tret.set(max(len(),rhs.len()));",
			"\t\tfor(int i=0;i<len();i++)ret[i]=v[i];",
			"\t\tfor(int i=0;i<rhs.len();i++)ret[i]+=rhs[i];",
			"\t\treturn ret;",
			"\t}",
			"\tvoid operator +=(const poly &rhs)",
			"\t{",
			"\t\tif(len()<rhs.len())set(rhs.len());",
			"\t\tfor(int i=0;i<rhs.len();i++)v[i]+=rhs[i];",
			"\t}",
			"\tpoly operator -(const poly &rhs)",
			"\t{",
			"\t\tpoly ret;",
			"\t\tret.set(max(len(),rhs.len()));",
			"\t\tfor(int i=0;i<len();i++)ret[i]=v[i];",
			"\t\tfor(int i=0;i<rhs.len();i++)ret[i]-=rhs[i];",
			"\t\treturn ret;",
			"\t}",
			"\tvoid operator -=(const poly &rhs)",
			"\t{",
			"\t\tif(len()<rhs.len())set(rhs.len());",
			"\t\tfor(int i=0;i<rhs.len();i++)v[i]-=rhs[i];",
			"\t}\t",
			"\tpair<poly,poly>operator %(poly rhs)",
			"\t{",
			"\t\tif(rhs.len()>len())return {{{0}},*this};",
			"\t\tpoly tmp0=*this,tmp1=rhs;",
			"\t\treverse(tmp0.v.begin(),tmp0.v.end());",
			"\t\treverse(tmp1.v.begin(),tmp1.v.end());",
			"\t\ttmp1=tmp1.getinv(len()-rhs.len()+1);",
			"\t\ttmp0*=tmp1;tmp0.set(len()-rhs.len()+1);",
			"\t\treverse(tmp0.v.begin(),tmp0.v.end());",
			"\t\tpoly r=*this;",
			"\t\ttmp1=tmp0*rhs;r=r-tmp1;r.set(rhs.len()-1);",
			"\t\treturn {tmp0,r};",
			"\t}",
			"\tpoly getinv(int deg=-1)",
			"\t{",
			"\t\tif(deg==-1)deg=len();",
			"\t\tif(deg==1)return {{qpow(v[0],mod-2)}};",
			"\t\tpoly ret=getinv((deg+1)>>1);",
			"\t\tint L=ceil(log2(deg))+1,n=1<<L;",
			"\t\tpoly tmp;tmp.set(deg);",
			"\t\tfor(int i=0;i<min(len(),deg);i++)tmp[i]=v[i];",
			"\t\ttmp.ntt(L,1);ret.ntt(L,1);",
			"\t\tfor(int i=0;i<n;i++)ret[i]=ret[i]*(2-tmp[i]*ret[i]);",
			"\t\tret.ntt(L,-1);ret.v.resize(deg);",
			"\t\treturn ret;",
			"\t}",
			"\tpoly getln(int deg=-1)",
			"\t{",
			"\t\tif(deg==-1)deg=len();",
			"\t\tpoly ret,rev=getinv();",
			"\t\tret.set(deg);",
			"\t\tfor(int i=0;i+1<len();i++)ret[i]=v[i+1]*(i+1);",
			"\t\tret*=rev;",
			"\t\tret.set(deg);",
			"\t\tstatic mint inv[1<<21];",
			"\t\tinv[1]=1;for(int i=2;i<ret.len();i++)inv[i]=(mod-mod/i)*inv[mod%i];",
			"\t\tfor(int i=ret.len()-1;i>=1;i--)ret[i]=ret[i-1]*inv[i];",
			"\t\tret[0]=0;",
			"\t\treturn ret;",
			"\t}",
			"\tpoly getexp(int deg=-1)",
			"\t{",
			"\t\tif(deg==-1)deg=len();",
			"\t\tif(deg==1)return {{1}};",
			"\t\tpoly ret=getexp((deg+1)>>1);",
			"\t\tret.set(deg);",
			"\t\tpoly ln=ret.getln();",
			"\t\tint L=ceil(log2(deg))+1,n=1<<L;",
			"\t\tln[0]=v[0]+1-ln[0];",
			"\t\tfor(int i=1;i<deg;i++)ln[i]=v[i]-ln[i];",
			"\t\tret*=ln;ret.set(deg);",
			"\t\treturn ret;",
			"\t}",
			"\tpoly getpow(int k)",
			"\t{",
			"\t\tpoly ln=getln();",
			"\t\tfor(mint &i:ln.v)i*=k;",
			"\t\treturn ln.getexp();",
			"\t}",
			"\tvector<mint>meval(vector<mint>x)",
			"\t{",
			"\t\tvector<poly>tmp(x.size()<<2);",
			"\t\tfunction<void(int,int,int)>get=[&](int u,int l,int r)",
			"\t\t{",
			"\t\t\tif(l==r){tmp[u]=poly{{-x[l],1}};return;}",
			"\t\t\tint mid=(l+r)>>1;",
			"\t\t\tget(u<<1,l,mid);get(u<<1|1,mid+1,r);",
			"\t\t\ttmp[u]=tmp[u<<1]*tmp[u<<1|1];\t",
			"\t\t};",
			"\t\tget(1,0,x.size()-1);",
			"\t\tvector<mint>ret;ret.resize(x.size());",
			"\t\tfunction<void(int,int,poly,int)>solve=[&](int l,int r,poly f,int u)",
			"\t\t{",
			"\t\t\tif(l==r){ret[l]=f[0];return;}",
			"\t\t\tint mid=(l+r)>>1;",
			"\t\t\tsolve(l,mid,(f%tmp[u<<1]).second,u<<1);",
			"\t\t\tsolve(mid+1,r,(f%tmp[u<<1|1]).second,u<<1|1);",
			"\t\t};",
			"\t\tsolve(0,x.size()-1,(*this%tmp[1]).second,1);",
			"\t\treturn ret;",
			"\t}",
			"\tvoid print(){for(mint &i:v)printf(\"%d \",i.v);putchar('\\n');}",
			"};",
			"int poly::R[];",
			"mint poly::W[];"			
		]
	},
	"exlucas": {
		"prefix": "zlucas",
		"body": [
			"namespace Exlucas",
			"{",
			"\tconst int maxn=2e4+5;",
			"\tconst int maxm=10;",
			"\tint mul[maxm],fac[maxm][maxn];",
			"\tvector<pair<int,int>>factor;",
			"\tint qpow(int a,ll b,int mod){int ret=1;for(;b;b>>=1,a=(ll)a*a%mod)if(b&1)ret=(ll)ret*a%mod;return ret;}",
			"\tvoid init(int mod)",
			"\t{",
			"\t\tint v=mod;",
			"\t\tfor(int i=2;i<=v/i;i++)",
			"\t\t\tif(v%i==0)",
			"\t\t\t{",
			"\t\t\t\tfactor.push_back({i,0});",
			"\t\t\t\twhile(v%i==0)v/=i,factor.back().second++;",
			"\t\t\t}",
			"\t\tif(v!=1)factor.push_back({v,1});",
			"\t\tfor(int i=0;i<factor.size();i++)mul[i]=qpow(factor[i].first,factor[i].second,mod+10);",
			"\t\tfor(int i=0;i<factor.size();i++)",
			"\t\t{",
			"\t\t\tfac[i][0]=1;",
			"\t\t\tfor(int j=1;j<=mul[i];j++)",
			"\t\t\t{",
			"\t\t\t\tfac[i][j]=fac[i][j-1];",
			"\t\t\t\tif(j%factor[i].first)fac[i][j]=(ll)fac[i][j]*j%mul[i];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn;",
			"\t}",
			"\tvoid exgcd(int a,int b,int &x,int &y)",
			"\t{",
			"\t\tif(b==0){x=1;y=0;return;}",
			"\t\texgcd(b,a%b,x,y);",
			"\t\tint z=x;x=y;y=z-y*(a/b);",
			"\t}",
			"\tint rev(int a,int b){int x0,y0;exgcd(a,b,x0,y0);x0=(x0%b+b)%b;return x0;}",
			"\tint exlucas(int n,int id)",
			"\t{",
			"\t\tif(n<=0)return 1;",
			"\t\tint ret=1;",
			"\t\tif(n>=mul[id])ret=qpow(fac[id][mul[id]],n/mul[id],mul[id]);",
			"\t\tfor(int i=2;i<=n%mul[id];i++)if(i%factor[id].first)ret=(ll)ret*i%mul[id];",
			"\t\tret=(ll)ret*exlucas(n/factor[id].first,id)%mul[id];",
			"\t\treturn ret;",
			"\t}",
			"\tint C(int n,int m,int id)",
			"\t{",
			"\t\tint ret=1;",
			"\t\tint last=0;",
			"\t\tfor(int i=n;i;i/=factor[id].first)last+=i/factor[id].first;",
			"\t\tfor(int i=m;i;i/=factor[id].first)last-=i/factor[id].first;",
			"\t\tfor(int i=n-m;i;i/=factor[id].first)last-=i/factor[id].first;",
			"\t\tif(last>=factor[id].second)return 0;",
			"\t\treturn (ll)qpow(factor[id].first,last,mul[id])*exlucas(n,id)%mul[id]*rev(exlucas(m,id),mul[id])%mul[id]*rev(exlucas(n-m,id),mul[id])%mul[id];",
			"\t}",
			"\tint a[maxm];",
			"\tint getans()",
			"\t{",
			"\t\tstatic int M[maxm];",
			"\t\tint ret=0;",
			"\t\tfor(int i=0;i<factor.size();i++)M[i]=mod/mul[i];",
			"\t\tfor(int i=0;i<factor.size();i++)",
			"\t\t{",
			"\t\t\tint x0,y0;",
			"\t\t\texgcd(M[i],mul[i],x0,y0);",
			"\t\t\tx0=(x0%mul[i]+mul[i])%mul[i];",
			"\t\t\t(ret+=(ll)M[i]*a[i]%mod*x0%mod)%=mod;",
			"\t\t}",
			"\t\treturn ret;",
			"\t}",
			"\tint C(int n,int m)",
			"\t{",
			"\t\tif(n<m||m<0)return 0;",
			"\t\tfor(int i=0;i<factor.size();i++)a[i]=C(n,m,i);",
			"\t\treturn getans();",
			"\t}",
			"}",
			"using Exlucas::init;",
			"using Exlucas::C;"
		]
	},
	"modint": {
		"prefix": "zmint",
		"body": [
			"int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=(ll)a*a%mod)if(b&1)ret=(ll)ret*a%mod;return ret;}",
			"class mint",
			"{",
			"\tpublic:",
			"\tint v;",
			"\tmint()=default;",
			"\tmint(int _v):v(_v){}",
			"\tmint& operator +=(const mint &rhs){v+=rhs.v;if(v>=mod)v-=mod;return *this;}",
			"\tmint& operator -=(const mint &rhs){v-=rhs.v;if(v<0)v+=mod;return *this;}",
			"\tmint& operator *=(const mint &rhs){v=(ll)v*rhs.v%mod;return *this;}",
			"\tmint& operator /=(const mint &rhs){v=(ll)v*rhs.inv().v%mod;return *this;}",
			"\tmint operator -()const{return v?mod-v:0;}",
			"\tfriend mint operator +(const mint &lhs,const mint &rhs){return (mint)lhs+=rhs;}",
			"\tfriend mint operator -(const mint &lhs,const mint &rhs){return (mint)lhs-=rhs;}",
			"\tfriend mint operator *(const mint &lhs,const mint &rhs){return (mint)lhs*=rhs;}",
			"\tfriend mint operator /(const mint &lhs,const mint &rhs){return (mint)lhs/=rhs;}",
			"\tfriend mint qpow(mint a,int b){mint ret=1;for(;b;b>>=1,a*=a)if(b&1)ret*=a;return ret;}",
			"\tmint inv()const{return qpow(v,mod-2);}",
			"};"
		]
	}
}